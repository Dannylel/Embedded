/*
 * ADC_prg.c
 *
 *  Created on: Feb 15, 2020
 *      Author: Dan
 */
#include"../Lib/Std_types.h"
#include"../Lib/Bit_math.h"
#include<avr/io.h>
#include"ADC_cfg.h"
#include"ADC_int.h"




void Adc_vidInit(void){


#if ADC_u8REF_VOLT == ADC_u8AREF
	CLR_BIT(ADMUX,7);	//7TH BIT REFS1	   AREF WITH INTERNAL
	CLR_BIT(ADMUX,6);	//6TH BIT REFS0    Vref TURNED OFF


#elif ADC_u8REF_VOLT == ADC_u8AVCC

	CLR_BIT(ADMUX,7);	//7TH BIT REFS1	   AVCC WITH EXTERNAL
	SET_BIT(ADMUX,6);	//6TH BIT REFS0    CAPACITOR AT AREF pin
#elif ADC_u8REF_VOLT == ADC_u8_2_56V

	SET_BIT(ADMUX,7);	//7TH BIT REFS1	   INTERNAL 2.56V VOLTAGE REFERENCE
	SET_BIT(ADMUX,6);	//6TH BIT REFS0    WITH EXTERNAL CAPACITOR AT AREF pin

#endif

#if ADC_u8RESULT_ADJUST == ADC_u8LEFT_ADJUST
	SET_BIT(ADMUX,5);	//LEFT ADJUSTED IN ADLAR BIT
#elif ADC_u8RESULT_ADJUST == ADC_u8RIGHT_ADJUST
	CLR_BIT(ADMUX,5);	//RIGHT ADJUSTED IN ADLAR BIT
#endif

#if ADC_u8AUTO_TRIGGER == ADC_u8TRIGGER_SOURCE_DISABLED

	CLR_BIT(ADCSRA,5);	//ADC AUTO TRIGGER ADATE DISABLED
#elif ADC_u8AUTO_TRIGGER == ADC_u8TRIGGER_SOURCE_FREE_RUN
	//Auto Trigger Enabled
	SET_BIT(ADCSRA,5);
	//Free Run Auto Trigger Selected
	CLR_BIT(SFIOR,7);
	CLR_BIT(SFIOR,6);
	CLR_BIT(SFIOR,5);
#elif ADC_u8AUTO_TRIGGER == ADC_u8TRIGGER_SOURCE_ANALOG_COMPARATOR
	//Auto Trigger Enabled
	SET_BIT(ADCSRA,5);
	//Analog Comparator Auto Trigger Selected
	CLR_BIT(SFIOR,7);
	CLR_BIT(SFIOR,6);
	SET_BIT(SFIOR,5);
#elif ADC_u8AUTO_TRIGGER ==	ADC_u8TRIGGER_SOURCE_EXTERNAL_INTERRUPT_REQUEST_0
	//Auto Trigger Enabled
	SET_BIT(ADCSRA,5);
	//External Interrupt Request0 Auto Trigger Selected
	CLR_BIT(SFIOR,7);
	SET_BIT(SFIOR,6);
	CLR_BIT(SFIOR,5);
#elif ADC_u8AUTO_TRIGGER == ADC_u8TRIGGER_SOURCE_TIMER_COUNTER_0_COMPARE_MATCH
	//Auto Trigger Enabled
	SET_BIT(ADCSRA,5);
	//Timer/Counter0 Compare Match Auto Trigger Selected
	CLR_BIT(SFIOR,7);
	SET_BIT(SFIOR,6);
	SET_BIT(SFIOR,5);
#elif ADC_u8AUTO_TRIGGER == ADC_u8TRIGGER_SOURCE_TIMER_COUNTER_0_OVERFLOW
	//Auto Trigger Enabled
	SET_BIT(ADCSRA,5);
	//Timer/Counter0 Overflow Auto Trigger Selected
	SET_BIT(SFIOR,7);
	CLR_BIT(SFIOR,6);
	CLR_BIT(SFIOR,5);
#elif ADC_u8AUTO_TRIGGER == ADC_u8TRIGGER_SOURCE_TIMER_COUNTER_COMPARE_MATCH_B
	//Auto Trigger Enabled
	SET_BIT(ADCSRA,5);
	//Timer/Counter Compare Match B Auto Trigger Selected
	SET_BIT(SFIOR,7);
	CLR_BIT(SFIOR,6);
	SET_BIT(SFIOR,5);
#elif ADC_u8AUTO_TRIGGER == ADC_u8TRIGGER_SOURCE_TIMER_COUNTER_1_OVERFLOW
	//Auto Trigger Enabled
	SET_BIT(ADCSRA,5);
	//Timer/Counter1 Overflow Auto Trigger Selected
	SET_BIT(SFIOR,7);
	SET_BIT(SFIOR,6);
	CLR_BIT(SFIOR,5);
#elif ADC_u8AUTO_TRIGGER == ADC_u8TRIGGER_SOURCE_TIMER_COUNTER_1_CAPTURE_EVENT
	//Auto Trigger Enabled
	SET_BIT(ADCSRA,5);
	//Timer/Counter1 Capture Event Auto Trigger Selected
	SET_BIT(SFIOR,7);
	SET_BIT(SFIOR,6);
	SET_BIT(SFIOR,5);

#endif
	CLR_BIT(ADMUX,4);	//ADC CHANNEL 0
	CLR_BIT(ADMUX,3);	//ADC CHANNEL 0
	CLR_BIT(ADMUX,2);	//ADC CHANNEL 0	page 212,213
	CLR_BIT(ADMUX,1);	//ADC CHANNEL 0
	CLR_BIT(ADMUX,0);	//ADC CHANNEL 0

	SET_BIT(ADCSRA,7);	//ENABLE ADC ADEN
	CLR_BIT(ADCSRA,6);	//ADSC ADC START CONVERSION DISABLED
	//CLR_BIT(ADCSRA,5);	//ADC AUTO TRIGGER ADATE DISABLED
	SET_BIT(ADCSRA,4);  //ADIF INTERRUPT FLAG CLEARED BY WRITING ONE TO IT
	CLR_BIT(ADCSRA,3);  //ADIE ADC INTERRUPT ENABLE CLEARED
#if	ADC_u8PRESCALER_VALUE == ADC_u8FCPU_2
	CLR_BIT(ADCSRA,2);  //ADPS2
	CLR_BIT(ADCSRA,1);	//ADPS1		PRESCALER SELECTED TO 2 MHZ
	SET_BIT(ADCSRA,0);	//ADPS0

#elif	ADC_u8PRESCALER_VALUE == ADC_u8FCPU_4
	CLR_BIT(ADCSRA,2);  //ADPS2
	SET_BIT(ADCSRA,1);	//ADPS1		PRESCALER SELECTED TO 4 MHZ
	CLR_BIT(ADCSRA,0);	//ADPS0

#elif	ADC_u8PRESCALER_VALUE == ADC_u8FCPU_8
	CLR_BIT(ADCSRA,2);  //ADPS2
	SET_BIT(ADCSRA,1);	//ADPS1		PRESCALER SELECTED TO 8 MHZ
	SET_BIT(ADCSRA,0);	//ADPS0

#elif	ADC_u8PRESCALER_VALUE == ADC_u8FCPU_16
	SET_BIT(ADCSRA,2);  //ADPS2
	CLR_BIT(ADCSRA,1);	//ADPS1		PRESCALER SELECTED TO 16 MHZ
	CLR_BIT(ADCSRA,0);	//ADPS0

#elif	ADC_u8PRESCALER_VALUE == ADC_u8FCPU_32
	SET_BIT(ADCSRA,2);  //ADPS2
	CLR_BIT(ADCSRA,1);	//ADPS1		PRESCALER SELECTED TO 32 MHZ
	SET_BIT(ADCSRA,0);	//ADPS0

#elif	ADC_u8PRESCALER_VALUE == ADC_u8FCPU_64
	SET_BIT(ADCSRA,2);  //ADPS2
	SET_BIT(ADCSRA,1);	//ADPS1		PRESCALER SELECTED TO 64 MHZ
	CLR_BIT(ADCSRA,0);	//ADPS0

#elif	ADC_u8PRESCALER_VALUE == ADC_u8FCPU_128
	SET_BIT(ADCSRA,2);  //ADPS2
	SET_BIT(ADCSRA,1);	//ADPS1		PRESCALER SELECTED TO 128 MHZ
	SET_BIT(ADCSRA,0);	//ADPS0

#endif
}

#if ADC_u8RESULT_ADJUST == ADC_u8RIGHT_ADJUST
u16 Adc_u16GetResult(u8 Chnl_Id)
#elif ADC_u8RESULT_ADJUST == ADC_u8LEFT_ADJUST
u8 Adc_u8GetResult(u8 Chnl_Id)
#endif
{
#if ADC_u8RESULT_ADJUST == ADC_u8RIGHT_ADJUST
	u16 result;
#elif ADC_u8RESULT_ADJUST == ADC_u8LEFT_ADJUST
	u8 result;
#endif
	ADMUX&=0b11100000;	//CLEAR 5 MUX BITS BEFORE SELECTING CHANNEL
	ADMUX|=(Chnl_Id&0b00011111);		//XOR-ING WITH OUTER 5 MUX BITS TO SELECT CHANNEL
	SET_BIT(ADCSRA,6); //START ADC
	while(GET_BIT(ADCSRA,4)==0); //CHECK FOR ADIF FLAG
	SET_BIT(ADCSRA,4);		//INTERRUPT FLAG CLEARED BY WRITING ONE

#if ADC_u8RESULT_ADJUST == ADC_u8RIGHT_ADJUST
	result=0;
	result=ADCL;			//RESULT CONTAINING THE LOWER 8 BITS OF THE ADC 10 BIT CHANNEL
	result|=(ADCH<<8);		//RESULT CONTAINGING THE HIGHER BITS OF THE ADC 10 BIT CHANNEL BY XOR-ING THE (LEFT SHIFTED BY 8 BITS)
#elif ADC_u8RESULT_ADJUST == ADC_u8LEFT_ADJUST
	result=ADCH;
#endif
	return result;
}
